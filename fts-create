#!/usr/bin/env node

let fs = require('fs')
let Database = require('better-sqlite3')
let lib = require('./lib/cli')
let common = require('./lib/common')
let html = require('./lib/html')

if (process.argv.length !== 2+2)
    lib.errx(1, 'Usage:', lib.prog, 'index.json out.sqlite3')
main(...process.argv.slice(2))

function main(indexfile, dbfile) {
    let index = lib.json(indexfile)
    let group_by_author = common.index_group_by(index, 'authors')
    let group_by_tag = common.index_group_by(index, 'tags')

    try { fs.unlinkSync(dbfile) } catch (e) { /* ignore */ }
    let db = new Database(dbfile)

    db.prepare(`CREATE VIRTUAL TABLE fts USING fts5(file UNINDEXED, subject UNINDEXED, date UNINDEXED, body)`).run()
    db.prepare(`CREATE TABLE metatags(file, type, name)`).run()

    metatags_add(db, group_by_author, 'author')
    metatags_add(db, group_by_tag, 'tag')
    posts_add(db, index.posts.concat(index.pages))
}

function metatags_add(db, group, type) {
    let ins = db.prepare(`INSERT INTO metatags(file,type,name) VALUES (?,?,?)`)
    for (let key in group)
	group[key].forEach( post => ins.run(post.file, type, key))
}

function posts_add(db, posts) {
    let ins = db.prepare(`INSERT INTO fts(file,subject,date,body) VALUES (?,?,?,?)`)
    for (let post of posts) {
	let body = md2txt(post.file)
	let date = common.birthtime(post.file)
	ins.run(post.file, post.subject, date ? date.toISOString() : null, body)
    }
}

function md2txt(file) {
    let mp = new lib.MarkdownParser(file)
    return [mp.front_matter().subject, mp.body()]
	.map(html.html2text).map(silly_escape)
	.join("\n\n")
}

// replace <,>,& with a similar looking chars
//
// WHY: we pass <b> tag to sqlite snipped() fn & inject the results of
// snipped() in a page as is, unescaped. This is an easy way to avoid
// providing a custom tokenizer (that would threat &lt; as <) for the
// `fts` table
function silly_escape(s) {
    if (s == null) return ''
    return s.toString().replace(/[<>&]/g, ch => {
        switch (ch) {
        case '<': return '‹' // single left-pointing angle quotation mark
        case '>': return '›' // single right-pointing ...
        case '&': return 'ε' // Greek small letter epsilon
        }
    })
}
