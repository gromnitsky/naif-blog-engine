#!/usr/bin/env node

'use strict';

let path = require('path')
let http = require('http')
let url = require('url')
let Database = require('better-sqlite3')
let shellparse = require('shell-quote').parse
let fts = require('./lib/fts')

if (process.argv.length < 3) {
    console.error('Usage:', path.basename(process.argv[1]), 'db.sqlite3')
    process.exit(1)
}
let db = new Database(process.argv[2], { readonly: true })
let finder = new fts.Finder(db)
let server = http.createServer(function (req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*')
    if (req.method !== "GET") { errx(res, 501, "not implemented"); return }

    let args = url.parse(req.url, true).query
    let argv = split_like_shell(args.q)
    if (!argv.length) { errx(res, 412, "no ?q=phrase"); return }

    let result
    try {
	result = finder.find(fts.Finder.argv_parse(argv))
    } catch(e) {
	errx(res, 500, e.message)
	return
    }

    res.setHeader('Content-Type', 'application/json')
    res.end(JSON.stringify(result))
})

server.listen(process.env.PORT || 3000, function() {
    console.error('Listening: http://'
		  + this.address().address + ":" + this.address().port)
})

function errx(res, code, msg) {
    try {
	res.statusCode = code
	res.statusMessage = msg
    } catch (e) {
	console.error(`errx: ${e.message}`)
    }
    res.end()
    console.error(`ERROR: ${msg}`)
}

function split_like_shell(s) {
    if (!s) return []
    return shellparse(s)
	.map( v => is_obj(v) && v.op === 'glob' ? v.pattern : v)
	.filter( v => !is_obj(v))
}

function is_obj(o) { return o === Object(o) }
