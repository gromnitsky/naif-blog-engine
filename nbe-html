#!/usr/bin/env node

let fs = require('fs')
let path = require('path')
let ejs = require('ejs')
let lib = require('./lib')

let argv = process.argv.slice(2)
if (argv.length !== 6) {
    console.error('Usage:', path.basename(process.argv[1]), 'file.md index.json config.json header.mustache body.mustache footer.mustache')
    process.exit(1)
}

let [index, config] = argv.slice(1,3)
    .map( v => JSON.parse(fs.readFileSync(v).toString()))
let [header, body, footer] = argv.slice(3,6)
    .map( v => fs.readFileSync(v).toString())
process.stdout.write(convert(argv[0], index, config, header, body, footer))


function convert(file, index, config, header, body, footer) {
    let view = {
	file,
	birthtime: birthtime(file), // posts
	root: rootdir(file),
	config,
	prev: prev_or_next(file, index, cur => cur-1), // posts
	next: prev_or_next(file, index, cur => cur+1), // posts
	contents: contents(file, index),
	authors: lib.index_group_by(index, 'authors'),
	tags: lib.index_group_by(index, 'tags'),
	get tags_inline() { return metatags_inline(file, 'tags', this.tags) },
	get authors_inline() { return metatags_inline(file, 'authors', this.authors) }
    }

    let fm
    let mp = new lib.MarkdownParser(file)
    try {
	fm = mp.front_matter()
    } catch (e) {
	// authors/tags file
	let type = path.dirname(file)
	view.subject = authors_tags(view[type+'s'], path.basename(file))
    }
    if (fm) view = Object.assign(view, fm, { body: mp.body() })

    header = ejs.render(header, view)
    body = ejs.render(body, view)
    footer = ejs.render(footer, view)

    return [header, body, footer].join("\n")
}

function authors_tags(group, target) {
    for (let candidate of Object.keys(group)) {
	if (target === lib.md5(candidate)) return candidate
    }
    throw new Error(`failed to find ${target}`)
}

function birthtime(file) {
    if (!lib.is_post(file)) return
    return new Date(file.split(path.sep).slice(0,3).join('-') + 'T00:00:00')
}

function prev_or_next(file, index, condition) {
    if (!lib.is_post(file)) return

    let cur = index.posts.findIndex( v => v.file === file)
    let idx = condition(cur)
    if (cur !== -1 && idx >= 0 && idx <= index.posts.length-1) return {
	link: file2link(index.posts[idx].file),
	subject: index.posts[idx].subject,
    }
}

function rootdir(file) { return path.dirname(file).replace(/[^/]+/g, '..') }

function file2link(file, relativeto) {
    return path.join(rootdir(relativeto || file),
		     file.replace(/\.md$/, '.html'))
}

function contents(file, index) {
    let tnode = (src, node_path) => {
	let root = new lib.TNode("root")
	src.forEach( val => {
	    let npath = node_path(val.file)
	    root.insert(npath, val)

	    // mark the node & its ancestors as "selected"
	    if (file === val.file) {
		let leaf = root.find(...npath)
		while (leaf) {
		    leaf.selected = true
		    leaf = leaf.parent
		}
	    }
	})
	return root
    }
    let node_path_posts = file => {
	let [y,m,d,n] = file.split(path.sep)
	return [y, m, path.join(d,n)]
    }
    let node_path_pages = file => {
	return file.split(path.sep).slice(1)
    }

    function tree(tnode, file) {
	let r = []
	tnode.kids.forEach( kid => {
	    r.push(`<details ${kid.selected ? 'open' : ''}>`)
	    if (!kid.kids.length) {
		if (kid.selected)
		    r.push(ejs.render('<summary class="selected"><%= subject %></summary>', {subject: kid.payload.subject}))
		else
		    r.push(ejs.render('<summary><a href="<%= link %>"><%= subject %></a></summary>', {link: file2link(kid.payload.file, file), subject: kid.payload.subject}))
	    } else {
		r.push(ejs.render('<summary><%= name %></summary>',
				  {name: kid.name}))
		r.push(tree(kid, file))
	    }
	    r.push('</details>')
	})
	return r.join('\n')
    }

    return {
	posts: tree(tnode(index.posts, node_path_posts), file),
	pages: tree(tnode(index.pages, node_path_pages), file),
    }
}

function metatags_inline(file, type, list) {
    return list.map( val => {
	return ejs.render('<a href="<%= link %>"><%= text %></a>', {
	    text: val,
	    link: metatags_link(file, type, val)
	})
    }).join(", ")
}

function metatags_link(relativeto, type, template) {
    let prefix = { tags: 't', authors: 'a' }[type]
    return path.join(rootdir(relativeto), prefix, lib.md5(template) + '.html')
}
