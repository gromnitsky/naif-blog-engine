#!/usr/bin/env node

let fs = require('fs')
let path = require('path')
let ejs = require('ejs')
let lib = require('./lib')

let argv = process.argv.slice(2)
if (argv.length !== 6) {
    lib.errx(1, 'Usage:', lib.prog,
	     'NAME index.json config.json header.ejs body.ejs footer.ejs')
}

let [index, config] = argv.slice(1,3).map(lib.json)
let [header, body, footer] = argv.slice(3,6)
    .map( v => fs.readFileSync(v).toString())
process.stdout.write(convert(argv[0], index, config, header, body, footer))


function convert(file, index, config, header, body, footer) {
    let view = {
	// posts only
	prev: prev_or_next(file, index, cur => cur-1),
	next: prev_or_next(file, index, cur => cur+1),

	file,
	index,
	root: rootdir(file),
	config,
	authors_group: lib.index_group_by(index, 'authors'),
	tags_group: lib.index_group_by(index, 'tags'),

	// helpers
	metatags_inline,
	is_post: lib.is_post,
	birthtime_ymd: birthtime_ymd,
	link,
	path,
    }

    let relativeto = file
    let fm
    let mp = new lib.MarkdownParser(file)
    try {
	fm = mp.front_matter()
    } catch (e) {
	// meta pages that don't have an explicit .md file as the input
	if (file === 'home') {
	    view.root = ''
	    view.subject = 'Home'
	    view.body = file => new lib.MarkdownParser(file).body({baseUrl: file})
	    relativeto = view.root
	} else { // authors/tags file
	    let type = path.dirname(file)
	    view.subject = metatags(view[type+'s_group'], path.basename(file))
	}
    }
    if (fm) view = Object.assign(view, fm, { body: mp.body() })

    view.contents = contents(relativeto, index)
    view.authors_list = metatags_list(relativeto, 'authors', view.authors_group)
    view.tags_list = metatags_list(relativeto, 'tags', view.tags_group)

    header = ejs.render(header, view)
    body = ejs.render(body, view)
    footer = ejs.render(footer, view)

    return [header, body, footer].join("\n")
}

function birthtime_ymd(file) {
    let d = birthtime(file)
    return d && [d.getFullYear(), d.getMonth()+1, d.getDate()].join('-')
}

function birthtime(file) {
    if (!lib.is_post(file)) return
    return new Date(file.split(path.sep).slice(0,3).join('-') + 'T00:00:00')
}

function prev_or_next(file, index, condition) {
    if (!lib.is_post(file)) return

    let cur = index.posts.findIndex( v => v.file === file)
    let idx = condition(cur)
    if (cur !== -1 && idx >= 0 && idx <= index.posts.length-1) return {
	link: link(index.posts[idx].file),
	subject: index.posts[idx].subject,
    }
}

function rootdir(file) {
    let np = path.normalize(file)
    if (/^\.\/*$/.test(np)) return np
    return path.dirname(file).replace(/[^/]+/g, '..')
}

function link(file, relativeto) {
    return path.join(rootdir(relativeto == null ? file : relativeto),
		     file.replace(/\.md$/, '.html'))
}

function contents(file, index) {
    let tnode = (src, node_path) => {
	let root = new lib.TNode("root")
	src.forEach( val => {
	    let npath = node_path(val.file)
	    root.insert(npath, val)

	    // mark the node & its ancestors as "selected"
	    if (file === val.file) {
		let leaf = root.find(...npath)
		while (leaf) {
		    leaf.selected = true
		    leaf = leaf.parent
		}
	    }
	})
	return root
    }
    let node_path_posts = file => {
	let [y,m,d,n] = file.split(path.sep)
	return [y, m, path.join(d,n)]
    }
    let node_path_pages = file => {
	return file.split(path.sep).slice(1)
    }

    function tree(tnode, file) {
	let r = []
	tnode.kids.forEach( kid => {
	    r.push(`<details ${kid.selected ? 'open' : ''}>`)
	    if (!kid.kids.length) {
		if (kid.selected)
		    r.push(ejs.render('<summary class="selected"><b><%= subject %></b></summary>', {subject: kid.payload.subject}))
		else
		    r.push(ejs.render('<summary><a href="<%= link %>"><%= subject %></a></summary>', {link: link(kid.payload.file, file), subject: kid.payload.subject}))
	    } else {
		r.push(ejs.render('<summary><%= name %></summary>',
				  {name: kid.name}))
		r.push(tree(kid, file))
	    }
	    r.push('</details>')
	})
	return r.join('\n')
    }

    return {
	posts: tree(tnode(index.posts, node_path_posts), file),
	pages: tree(tnode(index.pages, node_path_pages), file),
    }
}

function metatags(group, target) {
    for (let candidate of Object.keys(group)) {
	if (target === lib.md5(candidate)) return candidate
    }
    throw new Error(`failed to find ${target}`)
}

function metatags_inline(relativeto, type, list) {
    return list.map( val => {
	return ejs.render('<a href="<%= link %>"><%= text %></a>', {
	    text: val,
	    link: metatags_link(relativeto, type, val)
	})
    }).join(", ")
}

function metatags_link(relativeto, type, template) {
    let prefix = { tags: 't', authors: 'a' }[type]
    return path.join(rootdir(relativeto), prefix, lib.md5(template) + '.html')
}

function metatags_list(relativeto, type, group) {
    return '<ul>' + Object.keys(group).map( name => {
	return ejs.render('<li><a href="<%= link %>"><%= name %></a> (<%= count %>)</li>', {
	    link: metatags_link(relativeto, type, name),
	    name,
	    count: group[name].length})
    }).join("\n") + '</ul>'
}
