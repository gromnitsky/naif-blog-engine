#!/usr/bin/env node

let fs = require('fs')
let path = require('path')
let ejs = require('ejs')
let lib = require('./lib')

let argv = process.argv.slice(2)
if (argv.length !== 6) {
    lib.errx(1, 'Usage:', lib.prog,
	     'NAME index.json config.json header.ejs body.ejs footer.ejs')
}

let [index, config] = argv.slice(1,3).map(lib.json)
let [header, body, footer] = argv.slice(3,6)
    .map( v => fs.readFileSync(v).toString())
process.stdout.write(convert(argv[0], index, config, header, body, footer))


function convert(file, index, config, header, body, footer) {
    let view = {
	file,
	index,
	config,

	// the same `index`, but from a different perspective
	group_by_author: lib.index_group_by(index, 'authors'),
	group_by_tag: lib.index_group_by(index, 'tags'),

	// helpers
	metatags_inline,
	is_post: lib.is_post,
	birthtime_ymd: birthtime_ymd, // useful for posts only
	link,
	path,
    }

    let markdown_parse = () => {
	let mp = new lib.MarkdownParser(file)
	let fm = mp.front_matter()
	view = Object.assign(view, fm, { body: mp.body() })
    }

    let relto = file
    view.root = rootdir(relto)

    switch (detect_input_type(file)) {
    case 'post':
	view.prev = prev_or_next(file, index, cur => cur-1)
	view.next = prev_or_next(file, index, cur => cur+1)
	markdown_parse()
	break
    case 'home':
	relto = ''
	view.root = relto
	view.subject = 'Home'
	view.body = file => new lib.MarkdownParser(file).body({baseUrl: file})
	break
    case 'metatags':
	view.subject = metatags(view['group_by_'+path.dirname(file)],
				path.basename(file))
	break
    default: // page
	markdown_parse()
    }

    // complex widgets
    view.authors_list = metatags_list(relto, 'authors', view.group_by_author)
    view.tags_list    = metatags_list(relto, 'tags', view.group_by_tag)
    view.contents     = contents(relto, index)

    header = ejs.render(header, view)
    body = ejs.render(body, view)
    footer = ejs.render(footer, view)

    return [header, body, footer].join("\n")
}

function detect_input_type(file) {
    if (lib.is_post(file)) return 'post'
    if (file === 'home') return 'home'
    if (/^(author|tag)$/.test(path.dirname(file))) return 'metatags'
    return 'page'
}

function birthtime_ymd(file) {
    let d = birthtime(file)
    return d && [d.getFullYear(), d.getMonth()+1, d.getDate()].join('-')
}

function birthtime(file) {
    if (!lib.is_post(file)) return
    return new Date(file.split(path.sep).slice(0,3).join('-') + 'T00:00:00')
}

function prev_or_next(file, index, condition) {
    if (!lib.is_post(file)) return

    let cur = index.posts.findIndex( v => v.file === file)
    let idx = condition(cur)
    if (cur !== -1 && idx >= 0 && idx <= index.posts.length-1) return {
	link: link(index.posts[idx].file),
	subject: index.posts[idx].subject,
    }
}

function rootdir(file) {
    let np = path.normalize(file)
    if (/^\.\/*$/.test(np)) return np
    return path.dirname(file).replace(/[^/]+/g, '..')
}

function link(file, relto) {
    return path.join(rootdir(relto == null ? file : relto),
		     file.replace(/\.md$/, '.html'))
}

function contents(file, index) {
    let tnode = (src, node_path) => {
	let root = new lib.TNode("root")
	src.forEach( val => {
	    let npath = node_path(val.file)
	    root.insert(npath, val)

	    // mark the node & its ancestors as "selected"
	    if (file === val.file) {
		let leaf = root.find(...npath)
		while (leaf) {
		    leaf.selected = true
		    leaf = leaf.parent
		}
	    }
	})
	return root
    }
    let node_path_posts = file => {
	let [y,m,d,n] = file.split(path.sep)
	return [y, m, path.join(d,n)]
    }
    let node_path_pages = file => {
	return file.split(path.sep).slice(1)
    }

    function tree(tnode, file) {
	let r = []
	tnode.kids.forEach( kid => {
	    r.push(`<details ${kid.selected ? 'open' : ''}>`)
	    if (!kid.kids.length) {
		if (kid.selected)
		    r.push(ejs.render('<summary class="selected"><b><%= subject %></b></summary>', {subject: kid.payload.subject}))
		else
		    r.push(ejs.render('<summary><a href="<%= link %>"><%= subject %></a></summary>', {link: link(kid.payload.file, file), subject: kid.payload.subject}))
	    } else {
		r.push(ejs.render('<summary><%= name %></summary>',
				  {name: kid.name}))
		r.push(tree(kid, file))
	    }
	    r.push('</details>')
	})
	return r.join('\n')
    }

    return {
	posts: tree(tnode(index.posts, node_path_posts), file),
	pages: tree(tnode(index.pages, node_path_pages), file),
    }
}

function metatags(group, target) {
    for (let candidate of Object.keys(group)) {
	if (target === lib.md5(candidate)) return candidate
    }
    throw new Error(`failed to find ${target}`)
}

function metatags_inline(relto, type, list) {
    return list.map( val => {
	return ejs.render('<a href="<%= link %>"><%= text %></a>', {
	    text: val,
	    link: metatags_link(relto, type, val)
	})
    }).join(", ")
}

function metatags_link(relto, type, template) {
    let prefix = { tags: 't', authors: 'a' }[type]
    return path.join(rootdir(relto), prefix, lib.md5(template) + '.html')
}

function metatags_list(relto, type, group) {
    return '<ul>' + Object.keys(group).map( name => {
	return ejs.render('<li><a href="<%= link %>"><%= name %></a> (<%= count %>)</li>', {
	    link: metatags_link(relto, type, name),
	    name,
	    count: group[name].length})
    }).join("\n") + '</ul>'
}
